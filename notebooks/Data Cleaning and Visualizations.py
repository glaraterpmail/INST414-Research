# -*- coding: utf-8 -*-
"""Sprint 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vDTpo1RqEh-R6TjTUyXfe7VUTGL3QsSo
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from google.colab import drive
import os

# Mount Google Drive
drive.mount('/content/drive')

# Change directory
os.chdir("/content/drive/MyDrive/INST414 Project")

# Load csv files
boxd_df = pd.read_csv("letterboxd.csv")
imdb_df = pd.read_csv("imdb_top_1000.csv")
criterion_df = pd.read_csv("criterion.csv")

"""IMDB"""

# Proper columm format
imdb_df['Runtime'] = imdb_df['Runtime'].astype(str).str.extract('(\d+)')
imdb_df['Runtime'] = pd.to_numeric(imdb_df['Runtime'], errors='coerce')

imdb_df['Release Year'] = imdb_df['Release Year'].astype(str).str.extract('(\d+)')
imdb_df['Release Year'] = pd.to_numeric(imdb_df['Release Year'], errors='coerce')

# Summary stats
imdb_mean_rating = imdb_df['IMDB_Rating'].mean()
imdb_median_runtime = imdb_df['Runtime'].median()
imdb_median_release = imdb_df['Release Year'].median()

print(f"Mean IMDb Rating: {imdb_mean_rating}")
print(f"Median Runtime: {imdb_median_runtime}")
print(f"Median Release Year: {imdb_median_release}")

# Descriptive statistics for IMDb ratings
imdb_ratings_stats = imdb_df['IMDB_Rating'].describe()

print("Descriptive Statistics for IMDb Ratings:")
imdb_ratings_stats

imdb_median_release = imdb_df['Release Year'].median()
print(f"Median Release Year: {imdb_median_release}")

imdb_df.columns = imdb_df.columns.str.strip()
imdb_df['Genre'] = imdb_df['Genre'].str.split(',').str[0]

# Top 10 most prevalent genres
imdb_top_genres = imdb_df['Genre'].value_counts().head(10).index

# Filter to include only top genres
imdb_genres_filter_df = imdb_df[imdb_df['Genre'].isin(imdb_top_genres)]
imdb_top_genres_list = list(imdb_top_genres)
print(f"Top Genres: {imdb_top_genres_list}")

# Find top 10 most prevalent directors
imdb_top_directors = imdb_df['Director'].value_counts().head(10).index

# Filter to include only top directors
imdb_directors_filter_df = imdb_df[imdb_df['Director'].isin(imdb_top_directors)]
imdb_top_directors_list = list(imdb_top_directors)
print(f"Top Directors: {imdb_top_directors_list}")

# Top 10 Genres
imdb_top_directors = imdb_df['Genre'].value_counts().head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x=imdb_top_directors.values, y=imdb_top_directors.index, palette='crest')
plt.title('Prevalence of Top 10 Genres')
plt.xlabel('Count')
plt.ylabel('Genres')
plt.tight_layout()
plt.show()

# Top 10 Directors
imdb_top_directors = imdb_df['Director'].value_counts().head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x=imdb_top_directors.values, y=imdb_top_directors.index, palette='crest')
plt.title('Prevalence of Top 10 Directors')
plt.xlabel('Count')
plt.ylabel('Directors')
plt.tight_layout()
plt.show()

"""Letterboxd"""

# Columns are properly formatted
boxd_df['runtime'] = boxd_df['runtime'].astype(str).str.extract('(\d+)')
boxd_df['runtime'] = pd.to_numeric(boxd_df['runtime'], errors='coerce')

boxd_df['Year'] = boxd_df['Year'].astype(str).str.extract('(\d+)')
boxd_df['Year'] = pd.to_numeric(boxd_df['Year'], errors='coerce')

# Summary statistics
boxd_mean_rating = boxd_df['AvgRating'].mean()
boxd_median_runtime = boxd_df['runtime'].median()
boxd_median_release = boxd_df['Year'].median()

print(f"Mean Letterboxd Rating: {boxd_mean_rating}")
print(f"Median Runtime: {boxd_median_runtime}")
print(f"Median Release Year: {boxd_median_release}")

# Descriptive statistics for Letterboxd ratings
boxd_ratings_stats = boxd_df['AvgRating'].describe()

print("Descriptive Statistics for Letterboxd Ratings:")
boxd_ratings_stats

boxd_median_release = boxd_df['Year'].median()
print(f"Median Release Year: {boxd_median_release}")

boxd_df.columns = boxd_df.columns.str.strip()

# Top 10 most prevalent countries
boxd_top_countries = boxd_df['country'].value_counts().head(10).index

# Filter to include top countries
boxd_countries_filter_df = boxd_df[boxd_df['country'].isin(boxd_top_countries)]
boxd_top_countries_list = list(boxd_top_countries)
print(f"Top Countries: {boxd_top_countries_list}")

# Top 10 most prevalent languages
boxd_top_languages = boxd_df['Language'].value_counts().head(10).index

# Filter to include top languages
boxd_languages_filter_df = boxd_df[boxd_df['Language'].isin(boxd_top_languages)]
boxd_top_languages_list = list(boxd_top_languages)
print(f"Top Languages: {boxd_top_languages_list}")

# Top 10 most prevalent directors
boxd_top_directors = boxd_df['Director'].value_counts().head(10).index

# Filter to include top directors
boxd_directors_filter_df = boxd_df[boxd_df['Director'].isin(boxd_top_directors)]
boxd_top_directors_list = list(boxd_top_directors)
print(f"Top Directors: {boxd_top_directors_list}")

# Top 10 Countries
top_countries = boxd_df['country'].value_counts().head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_countries.values, y=top_countries.index, palette='viridis')
plt.title('Top 10 Most Prevalent Countries')
plt.xlabel('Count')
plt.ylabel('Countries')
plt.tight_layout()
plt.show()

# Top 10 Languages
top_languages = boxd_df['Language'].value_counts().head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_languages.values, y=top_languages.index, palette='magma')
plt.title('Top 10 Most Prevalent Languages')
plt.xlabel('Count')
plt.ylabel('Languages')
plt.tight_layout()
plt.show()

# Top 10 Directors
top_directors = boxd_df['Director'].value_counts().head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_directors.values, y=top_directors.index, palette='coolwarm')
plt.title('Top 10 Most Prevalent Directors')
plt.xlabel('Count')
plt.ylabel('Directors')
plt.tight_layout()
plt.show()

"""Criterion"""

criterion_df.describe()

criterion_median_release = criterion_df['Year'].median()
print(f"Median Release Year: {criterion_median_release}")

criterion_df.columns = criterion_df.columns.str.strip()

# Top 10 most prevalent countries
criterion_top_countries = criterion_df['Country'].value_counts().head(10).index

# Filter to include top countries
criterion_countries_filter_df = criterion_df[criterion_df['Country'].isin(criterion_top_countries)]
criterion_top_countries_list = list(criterion_top_countries)
print(f"Top Countries: {criterion_top_countries_list}")

# Top 10 most prevalent languages
criterion_top_languages = criterion_df['Language'].value_counts().head(10).index

# Filter to include the top languages
criterion_languages_filter_df = criterion_df[criterion_df['Language'].isin(criterion_top_languages)]
criterion_top_languages_list = list(criterion_top_languages)
print(f"Top Languages: {criterion_top_languages_list}")

# Top 10 most prevalent directors
criterion_top_directors = criterion_df['Director'].value_counts().head(10).index

# Filter to include top directors
criterion_directors_filter_df = criterion_df[criterion_df['Director'].isin(criterion_top_directors)]
criterion_top_directors_list = list(criterion_top_directors)
print(f"Top Directors: {criterion_top_directors_list}")

# Top 10 Languages
criterion_top_languages = criterion_df['Language'].value_counts().head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=criterion_top_languages.values, y=criterion_top_languages.index, palette='viridis')
plt.title('Prevalence of Top 10 Languages')
plt.xlabel('Count')
plt.ylabel('Languages')
plt.tight_layout()
plt.show()

# Top 10 Countries
criterion_top_countries = criterion_df['Country'].value_counts().head(10)
plt.figure(figsize=(10, 6))
sns.barplot(x=criterion_top_countries.values, y=criterion_top_countries.index, palette='magma')
plt.title('Prevalence of Top 10 Countries')
plt.xlabel('Count')
plt.ylabel('Countries')
plt.tight_layout()
plt.show()

# Top 10 Directors
criterion_top_directors = criterion_df['Director'].value_counts().head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x=criterion_top_directors.values, y=criterion_top_directors.index, palette='crest')
plt.title('Prevalence of Top 10 Directors')
plt.xlabel('Count')
plt.ylabel('Directors')
plt.tight_layout()
plt.show()

"""Cross-analysis"""

# Column in Letterboxd dataset to match IMDb and Criterion
boxd_df = boxd_df.rename(columns={"film.title": "Title"})

# Merge IMDb and Letterboxd datasets on 'Title'
merged_boxdimdb_df = pd.merge(imdb_df, boxd_df, on='Title', suffixes=('_imdb', '_boxd'))

# Merge the result with Criterion dataset on 'Title'
merged_boxdimdb_df = pd.merge(merged_boxdimdb_df, criterion_df, on='Title', suffixes=('', '_criterion'))

# Save to CSV file
merged_boxdimdb_df.to_csv('merged_dataset.csv', index=False)

# Merge the result with Criterion dataset on 'Title'
merged_critboxdimdb_df = pd.merge(
    merged_boxdimdb_df,
    criterion_df,
    on='Title',
    suffixes=('', '_criterion')
)

# Group data by director and calculate aggregate statistics
director_data = merged_critboxdimdb_df.groupby('Director').agg({
    'IMDB_Rating': 'mean',       # Average IMDb rating
    'AvgRating': 'mean',         # Average Letterboxd rating
    'Year': 'mean'               # Average release year
}).dropna()

# Count appearances in IMDb and Letterboxd merged dataset
imdb_letterboxd_counts = merged_boxdimdb_df.groupby('Director').size().reset_index(name='IMDB_Letterboxd_Count')

# Count appearances in Criterion dataset
criterion_counts = criterion_df.groupby('Director').size().reset_index(name='Criterion_Count')

# Merge into a single dataframe
director_counts = pd.merge(
    imdb_letterboxd_counts,
    criterion_counts,
    on='Director',
    how='outer'
).fillna(0)

# Total appearance column for combined analysis
director_counts['Total_Appearances'] = (
    director_counts['IMDB_Letterboxd_Count'] + director_counts['Criterion_Count']
)

# Combine aggregate metrics with counts
final_director_data = pd.merge(
    director_data,
    director_counts,
    on='Director',
    how='left'
).fillna(0)

# Sort by total appearances to find the most frequently appearing directors
sorted_directors = final_director_data.sort_values(by='Total_Appearances', ascending=False)

# Top 10 directors based on Total_Appearances
top_10_directors = sorted_directors.head(10)

# Normalize IMDb and Letterboxd ratings
normalized_ratings = (top_10_directors[['IMDB_Rating', 'AvgRating']] -
                      top_10_directors[['IMDB_Rating', 'AvgRating']].min()) / (
                      top_10_directors[['IMDB_Rating', 'AvgRating']].max() -
                      top_10_directors[['IMDB_Rating', 'AvgRating']].min())

# Heatmap for IMDb and Letterboxd ratings
plt.figure(figsize=(12, 8))
sns.heatmap(normalized_ratings, annot=True, cmap="coolwarm",
            xticklabels=['IMDb Rating', 'Letterboxd Rating'],
            yticklabels=top_10_directors['Director'])
plt.title("Heatmap: IMDb and Letterboxd Ratings for Top Directors")
plt.xlabel("Ratings")
plt.ylabel("Directors")
plt.tight_layout()
plt.show()

# Group data by Genre and calculate avg IMDb and Letterboxd ratings
genre_data = merged_critboxdimdb_df.groupby('Genre').agg({
    'IMDB_Rating': 'mean',
    'AvgRating': 'mean'
}).dropna()

# Normalize IMDb and Letterboxd ratings for fair comparison
normalized_genre_ratings = (genre_data[['IMDB_Rating', 'AvgRating']] -
                            genre_data[['IMDB_Rating', 'AvgRating']].min()) / (
                            genre_data[['IMDB_Rating', 'AvgRating']].max() -
                            genre_data[['IMDB_Rating', 'AvgRating']].min())

# Create heatmap with additional insights
plt.figure(figsize=(14, 10))
sns.heatmap(normalized_genre_ratings, annot=True, cmap="coolwarm",
            xticklabels=['IMDb Rating', 'Letterboxd Rating'],
            yticklabels=genre_data.index)

plt.title("Heatmap: IMDb vs. Letterboxd Ratings by Genre")
plt.xlabel("Ratings")
plt.ylabel("Genres")
plt.tight_layout()
plt.show()

# Top 10 Directors by prevalence in the Criterion collection
criterion_top_directors = criterion_df['Director'].value_counts().head(10)

# Get list of top 10 director names
criterion_top_directors_list = criterion_top_directors.index.tolist()

# Filter the merged dataset for only those top directors
top_directors_df = merged_critboxdimdb_df[merged_critboxdimdb_df['Director'].isin(criterion_top_directors_list)]

# Plot histograms for IMDb and Letterboxd ratings (scaled to 10)
plt.figure(figsize=(12, 6))

sns.histplot(top_directors_df['IMDB_Rating'], kde=True, color='blue', label='IMDb Ratings', bins=20)
sns.histplot(top_directors_df['AvgRating'] * 2, kde=True, color='orange', label='Letterboxd Ratings (Scaled)', bins=20)

plt.title('Distribution of Ratings Across Platforms (Top 10 Criterion Directors)')
plt.xlabel('Rating (Out of 10)')
plt.ylabel('Frequency')
plt.legend()
plt.tight_layout()
plt.show()

"""## K-Means Clustering

* Genres are clustered based on normalized IMDb vs. Letterboxd rating differences.
* This identifies genres where audience perceptions diverge—e.g., Letterboxd users favoring
* artistic depth versus IMDb favoring mainstream appeal.
* Scaling Letterboxd scores to a 10-point scale ensures fair comparison.
* Reveals audience perception gaps—where IMDb may favor mainstream appeal and Letterboxd highlights artistic preferences.


"""

# K-Means Clustering: Genre-Based Rating Differences (Adjusted for Rating Scales)
from sklearn.cluster import KMeans

# Group data by Genre and calculate average IMDb and Letterboxd ratings
genre_data = merged_critboxdimdb_df.groupby('Genre').agg({
    'IMDB_Rating': 'mean',  # Average IMDb rating
    'AvgRating': 'mean'     # Average Letterboxd rating
}).dropna()

# Adjust Letterboxd ratings to match IMDb's 10-point scale
genre_data['Adjusted_LBX'] = genre_data['AvgRating'] * 2

# Normalize IMDb and adjusted Letterboxd ratings
normalized_genre_ratings = (genre_data[['IMDB_Rating', 'Adjusted_LBX']] -
                            genre_data[['IMDB_Rating', 'Adjusted_LBX']].min()) / (
                            genre_data[['IMDB_Rating', 'Adjusted_LBX']].max() -
                            genre_data[['IMDB_Rating', 'Adjusted_LBX']].min())

# Normalized rating data for clustering
genre_rating_data = normalized_genre_ratings.copy()

# KMeans clustering with 4 clusters
kmeans = KMeans(n_clusters=4, random_state=42)
genre_rating_data['Cluster'] = kmeans.fit_predict(genre_rating_data)

# Plot
plt.figure(figsize=(10, 6))
sns.scatterplot(
    x=genre_rating_data['IMDB_Rating'],
    y=genre_rating_data['Adjusted_LBX'],
    hue=genre_rating_data['Cluster'],
    palette='coolwarm',
    s=100
)
plt.title("Clustering Genres by IMDb vs. Letterboxd Rating Gaps")
plt.xlabel("IMDb Rating")
plt.ylabel("Letterboxd Rating (Adjusted to 10-Point Scale)")
plt.legend(title='Cluster')
plt.grid(True)
plt.show()